// 1. Метод для суммирования двух чисел
static int Sum(int a, int b)
{
    return a + b;
}

// 2. Метод для суммирования двух чисел
static int Sum(int a, int b)
{
    return a + b;
}

// 3. Максимум из трех чисел
static int MaxOfThree(int a, int b, int c)
{
    int max = a;
    if (b > max) max = b;
    if (c > max) max = c;
    return max;
}

// 4. Проверка четности
static bool IsEven(int n)
{
    return n % 2 == 0;
}

// 5. Проверка четности
static bool IsEven(int n)
{
    return n % 2 == 0;
}

// 6. Проверка четности
static bool IsEven(int n)
{
    return n % 2 == 0;
}

// 7. Суммирование двух чисел
static int Sum(int a, int b)
{
    return a + b;
}

// 8. Метод, выводящий все числа в диапазоне от a до b
static void PrintRange(int a, int b)
{
    for (int i = a; i <= b; i++)
        Console.WriteLine(i);
}

// 9. Суммирование двух чисел
static int Sum(int a, int b)
{
    return a + b;
}

// 10. Метод, выводящий все числа в диапазоне от a до b
static void PrintRange(int a, int b)
{
    for (int i = a; i <= b; i++)
        Console.WriteLine(i);
}

// 11. Метод для расчета факториала числа
static long Factorial(int n)
{
    if (n < 0) throw new ArgumentException("Число не может быть отрицательным");
    long result = 1;
    for (int i = 2; i <= n; i++)
        result *= i;
    return result;
}

// 12. Метод для суммирования двух чисел
static int Sum(int a, int b)
{
    return a + b;
}

// 13. Метод для суммирования двух чисел
static int Sum(int a, int b)
{
    return a + b;
}

// 14. Метод для суммирования двух чисел
static int Sum(int a, int b)
{
    return a + b;
}

// 15. Проверка четности
static bool IsEven(int n)
{
    return n % 2 == 0;
}

// 16. Проверка четности
static bool IsEven(int n)
{
    return n % 2 == 0;
}

// 17. Метод, выводящий все числа в диапазоне от a до b
static void PrintRange(int a, int b)
{
    for (int i = a; i <= b; i++)
        Console.WriteLine(i);
}

// 18. Метод, выводящий все числа в диапазоне от a до b
static void PrintRange(int a, int b)
{
    for (int i = a; i <= b; i++)
        Console.WriteLine(i);
}

// 19. Метод для суммирования двух чисел
static int Sum(int a, int b)
{
    return a + b;
}

// 20. Метод, выводящий все числа в диапазоне от a до b
static void PrintRange(int a, int b)
{
    for (int i = a; i <= b; i++)
        Console.WriteLine(i);
}

// 21. Функция, возвращающая квадрат числа
static int Square(int number)
{
    return number * number;
}

// 22. Функция, проверяющая, является ли строка палиндромом
static bool IsPalindrome(string str)
{
    if (string.IsNullOrEmpty(str)) return true;
    string cleanStr = str.Replace(" ", "").ToLower();
    return cleanStr.SequenceEqual(cleanStr.Reverse());
}

// 23. Процедура, изменяющая значение переменной через ref
static void ModifyValue(ref int value)
{
    value *= 2;
}

// 24. Функция, возвращающая квадрат числа
static int Square(int number)
{
    return number * number;
}

// 25. Процедура, изменяющая значение переменной через ref
static void ModifyValue(ref int value)
{
    value += 10;
}

// 26. Функция, проверяющая, является ли строка палиндромом
static bool IsPalindrome(string str)
{
    if (string.IsNullOrEmpty(str)) return true;
    string cleanStr = str.Replace(" ", "").ToLower();
    return cleanStr.SequenceEqual(cleanStr.Reverse());
}

// 27. Различие между процедурой и функцией на примере
static int FunctionExample(int x) // Функция - возвращает значение
{
    return x * x;
}

static void ProcedureExample(int x) // Процедура - не возвращает значение
{
    Console.WriteLine(x * x);
}

// 28. Процедура, которая выводит 'Hello, World!' на экран
static void PrintHelloWorld()
{
    Console.WriteLine("Hello, World!");
}

// 29. Функция, возвращающая квадрат числа
static int Square(int number)
{
    return number * number;
}

// 30. Процедура, изменяющая значение переменной через ref
static void ModifyValue(ref int value)
{
    value = value * 3;
}

// 31. Различие между процедурой и функцией на примере
static string FunctionGetGreeting(string name)
{
    return $"Hello, {name}!";
}

static void ProcedurePrintGreeting(string name)
{
    Console.WriteLine($"Hello, {name}!");
}

// 32. Различие между процедурой и функцией на примере
static double FunctionCalculateArea(double radius)
{
    return Math.PI * radius * radius;
}

static void ProcedureDisplayArea(double radius)
{
    double area = Math.PI * radius * radius;
    Console.WriteLine($"Area: {area}");
}

// 33. Функция, возвращающая квадрат числа
static int Square(int number)
{
    return number * number;
}

// 34. Функция, возвращающая квадрат числа
static int Square(int number)
{
    return number * number;
}

// 35. Различие между процедурой и функцией на примере
static int FunctionAdd(int a, int b)
{
    return a + b;
}

static void ProcedureAdd(int a, int b)
{
    Console.WriteLine($"{a} + {b} = {a + b}");
}

// 36. Процедура, которая выводит 'Hello, World!' на экран
static void PrintHelloWorld()
{
    Console.WriteLine("Hello, World!");
}

// 37. Процедура, которая выводит 'Hello, World!' на экран
static void PrintHelloWorld()
{
    Console.WriteLine("Hello, World!");
}

// 38. Процедура, изменяющая значение переменной через ref
static void ModifyValue(ref int value)
{
    value -= 5;
}

// 39. Процедура, которая выводит 'Hello, World!' на экран
static void PrintHelloWorld()
{
    Console.WriteLine("Hello, World!");
}

// 40. Различие между процедурой и функцией на примере
static bool FunctionIsEven(int number)
{
    return number % 2 == 0;
}

static void ProcedureCheckEven(int number)
{
    Console.WriteLine($"{number} is {(number % 2 == 0 ? "even" : "odd")}");
}

// 41. Различие между процедурой и функцией на примере
static string FunctionReverse(string str)
{
    return new string(str.Reverse().ToArray());
}

static void ProcedureReverse(string str)
{
    string reversed = new string(str.Reverse().ToArray());
    Console.WriteLine(reversed);
}

// 42. Функция, проверяющая, является ли строка палиндромом
static bool IsPalindrome(string str)
{
    if (string.IsNullOrEmpty(str)) return true;
    string cleanStr = str.Replace(" ", "").ToLower();
    return cleanStr.SequenceEqual(cleanStr.Reverse());
}

// 43. Различие между процедурой и функцией на примере
static double FunctionCalculateBMI(double weight, double height)
{
    return weight / (height * height);
}

static void ProcedureCalculateBMI(double weight, double height)
{
    double bmi = weight / (height * height);
    Console.WriteLine($"BMI: {bmi:F2}");
}

// 44. Процедура, которая выводит 'Hello, World!' на экран
static void PrintHelloWorld()
{
    Console.WriteLine("Hello, World!");
}

// 45. Процедура, изменяющая значение переменной через ref
static void ModifyValue(ref int value)
{
    value = value * value;
}

// 46. Метод для поиска минимального элемента в массиве
static int FindMin(int[] array)
{
    if (array == null || array.Length == 0)
        throw new ArgumentException("Массив не может быть пустым");
    
    int min = array[0];
    for (int i = 1; i < array.Length; i++)
    {
        if (array[i] < min)
            min = array[i];
    }
    return min;
}

// 47. Метод, принимающий массив и вычисляющий его среднее значение
static double CalculateAverage(int[] array)
{
    if (array == null || array.Length == 0)
        throw new ArgumentException("Массив не может быть пустым");
    
    int sum = 0;
    foreach (int num in array)
        sum += num;
    
    return (double)sum / array.Length;
}

// 48. Метод для копирования массива
static int[] CopyArray(int[] source)
{
    if (source == null) return null;
    
    int[] copy = new int[source.Length];
    for (int i = 0; i < source.Length; i++)
        copy[i] = source[i];
    
    return copy;
}

// 49. Метод, принимающий массив и вычисляющий его среднее значение
static double CalculateAverage(int[] array)
{
    if (array == null || array.Length == 0)
        throw new ArgumentException("Массив не может быть пустым");
    
    int sum = 0;
    foreach (int num in array)
        sum += num;
    
    return (double)sum / array.Length;
}

// 50. Метод для поиска минимального элемента в массиве
static int FindMin(int[] array)
{
    if (array == null || array.Length == 0)
        throw new ArgumentException("Массив не может быть пустым");
    
    int min = array[0];
    for (int i = 1; i < array.Length; i++)
    {
        if (array[i] < min)
            min = array[i];
    }
    return min;
}

// 51. Метод, принимающий строку и возвращающий ее длину
static int GetStringLength(string str)
{
    return str?.Length ?? 0;
}

// 52. Метод для поиска минимального элемента в массиве
static int FindMin(int[] array)
{
    if (array == null || array.Length == 0)
        throw new ArgumentException("Массив не может быть пустым");
    
    int min = array[0];
    for (int i = 1; i < array.Length; i++)
    {
        if (array[i] < min)
            min = array[i];
    }
    return min;
}

// 53. Метод, принимающий строку и возвращающий ее длину
static int GetStringLength(string str)
{
    return str?.Length ?? 0;
}

// 54. Метод для поиска минимального элемента в массиве
static int FindMin(int[] array)
{
    if (array == null || array.Length == 0)
        throw new ArgumentException("Массив не может быть пустым");
    
    int min = array[0];
    for (int i = 1; i < array.Length; i++)
    {
        if (array[i] < min)
            min = array[i];
    }
    return min;
}

// 55. Перегруженный метод для сложения двух и трех чисел
static int Add(int a, int b)
{
    return a + b;
}

static int Add(int a, int b, int c)
{
    return a + b + c;
}

// 56. Метод, принимающий массив и вычисляющий его среднее значение
static double CalculateAverage(int[] array)
{
    if (array == null || array.Length == 0)
        throw new ArgumentException("Массив не может быть пустым");
    
    int sum = 0;
    foreach (int num in array)
        sum += num;
    
    return (double)sum / array.Length;
}

// 57. Метод, принимающий массив и вычисляющий его среднее значение
static double CalculateAverage(int[] array)
{
    if (array == null || array.Length == 0)
        throw new ArgumentException("Массив не может быть пустым");
    
    int sum = 0;
    foreach (int num in array)
        sum += num;
    
    return (double)sum / array.Length;
}

// 58. Перегруженный метод для сложения двух и трех чисел
static int Add(int a, int b)
{
    return a + b;
}

static int Add(int a, int b, int c)
{
    return a + b + c;
}

// 59. Метод, принимающий строку и возвращающий ее длину
static int GetStringLength(string str)
{
    return str?.Length ?? 0;
}

// 60. Метод, принимающий массив и вычисляющий его среднее значение
static double CalculateAverage(int[] array)
{
    if (array == null || array.Length == 0)
        throw new ArgumentException("Массив не может быть пустым");
    
    int sum = 0;
    foreach (int num in array)
        sum += num;
    
    return (double)sum / array.Length;
}

// 61. Перегруженный метод для сложения двух и трех чисел
static int Add(int a, int b)
{
    return a + b;
}

static int Add(int a, int b, int c)
{
    return a + b + c;
}

// 62. Метод, принимающий массив и вычисляющий его среднее значение
static double CalculateAverage(int[] array)
{
    if (array == null || array.Length == 0)
        throw new ArgumentException("Массив не может быть пустым");
    
    int sum = 0;
    foreach (int num in array)
        sum += num;
    
    return (double)sum / array.Length;
}

// 63. Метод для копирования массива
static int[] CopyArray(int[] source)
{
    if (source == null) return null;
    
    int[] copy = new int[source.Length];
    for (int i = 0; i < source.Length; i++)
        copy[i] = source[i];
    
    return copy;
}

// 64. Метод, принимающий строку и возвращающий ее длину
static int GetStringLength(string str)
{
    return str?.Length ?? 0;
}

// 65. Метод для копирования массива
static int[] CopyArray(int[] source)
{
    if (source == null) return null;
    
    int[] copy = new int[source.Length];
    for (int i = 0; i < source.Length; i++)
        copy[i] = source[i];
    
    return copy;
}

// 66. Метод, принимающий строку и возвращающий ее длину
static int GetStringLength(string str)
{
    return str?.Length ?? 0;
}

// 67. Перегруженный метод для сложения двух и трех чисел
static int Add(int a, int b)
{
    return a + b;
}

static int Add(int a, int b, int c)
{
    return a + b + c;
}

// 68. Метод, принимающий строку и возвращающий ее длину
static int GetStringLength(string str)
{
    return str?.Length ?? 0;
}

// 69. Метод, принимающий строку и возвращающий ее длину
static int GetStringLength(string str)
{
    return str?.Length ?? 0;
}

// 70. Перегруженный метод для сложения двух и трех чисел
static int Add(int a, int b)
{
    return a + b;
}

static int Add(int a, int b, int c)
{
    return a + b + c;
}

// 71. Метод, принимающий строку и возвращающий ее длину
static int GetStringLength(string str)
{
    return str?.Length ?? 0;
}

// 72. Метод, принимающий массив и вычисляющий его среднее значение
static double CalculateAverage(int[] array)
{
    if (array == null || array.Length == 0)
        throw new ArgumentException("Массив не может быть пустым");
    
    int sum = 0;
    foreach (int num in array)
        sum += num;
    
    return (double)sum / array.Length;
}

// 73. Метод для поиска минимального элемента в массиве
static int FindMin(int[] array)
{
    if (array == null || array.Length == 0)
        throw new ArgumentException("Массив не может быть пустым");
    
    int min = array[0];
    for (int i = 1; i < array.Length; i++)
    {
        if (array[i] < min)
            min = array[i];
    }
    return min;
}

// 74. Перегруженный метод для сложения двух и трех чисел
static int Add(int a, int b)
{
    return a + b;
}

static int Add(int a, int b, int c)
{
    return a + b + c;
}

// 75. Метод для поиска минимального элемента в массиве
static int FindMin(int[] array)
{
    if (array == null || array.Length == 0)
        throw new ArgumentException("Массив не может быть пустым");
    
    int min = array[0];
    for (int i = 1; i < array.Length; i++)
    {
        if (array[i] < min)
            min = array[i];
    }
    return min;
}

// 76. Функция, возвращающая код ошибки, если входные данные некорректны
static int ValidateData(int data)
{
    if (data < 0) return -1; // код ошибки для отрицательных данных
    if (data > 1000) return -2; // код ошибки для слишком больших данных
    return 0; // успех
}

// 77. Функция, возвращающая код ошибки, если входные данные некорректны
static int ValidateString(string str)
{
    if (string.IsNullOrEmpty(str)) return -1;
    if (str.Length < 3) return -2;
    return 0;
}

// 78. Функция, проверяющая делимость на 3 и возвращающая true/false
static bool IsDivisibleByThree(int number)
{
    return number % 3 == 0;
}

// 79. Функция, проверяющая делимость на 3 и возвращающая true/false
static bool IsDivisibleByThree(int number)
{
    return number % 3 == 0;
}

// 80. Функция, использующая return для выхода из метода до конца выполнения
static string ProcessNumber(int number)
{
    if (number < 0)
        return "Отрицательное число не обрабатывается";
    
    if (number == 0)
        return "Ноль";
    
    // Дальнейшая обработка для положительных чисел
    return $"Положительное число: {number}";
}

// 81. Функция, возвращающая null, если строка пустая
static string ProcessString(string input)
{
    if (string.IsNullOrEmpty(input))
        return null;
    
    return input.ToUpper();
}

// 82. Функция, возвращающая код ошибки, если входные данные некорректны
static int ValidateAge(int age)
{
    if (age < 0) return -1;
    if (age > 150) return -2;
    return 0;
}

// 83. Функция, использующая return для выхода из метода до конца выполнения
static int SafeDivide(int a, int b)
{
    if (b == 0)
    {
        Console.WriteLine("Деление на ноль!");
        return 0;
    }
    
    return a / b;
}

// 84. Функция с несколькими return, которые завершат выполнение в зависимости от условий
static string EvaluateGrade(int score)
{
    if (score >= 90) return "A";
    if (score >= 80) return "B";
    if (score >= 70) return "C";
    if (score >= 60) return "D";
    return "F";
}

// 85. Функция, возвращающая код ошибки, если входные данные некорректны
static int ValidateEmail(string email)
{
    if (string.IsNullOrEmpty(email)) return -1;
    if (!email.Contains("@")) return -2;
    return 0;
}

// 86. Функция с несколькими return, которые завершат выполнение в зависимости от условий
static string GetTimeOfDay(int hour)
{
    if (hour < 0 || hour > 23) return "Неверный час";
    if (hour < 6) return "Ночь";
    if (hour < 12) return "Утро";
    if (hour < 18) return "День";
    return "Вечер";
}

// 87. Функция, использующая return для выхода из метода до конца выполнения
static double CalculateSquareRoot(double number)
{
    if (number < 0)
    {
        Console.WriteLine("Нельзя извлечь корень из отрицательного числа");
        return double.NaN;
    }
    
    return Math.Sqrt(number);
}

// 88. Функция, проверяющая делимость на 3 и возвращающая true/false
static bool IsDivisibleByThree(int number)
{
    return number % 3 == 0;
}

// 89. Функция, использующая return для выхода из метода до конца выполнения
static string CheckTemperature(double temp)
{
    if (temp < -273.15)
        return "Температура ниже абсолютного нуля";
    
    if (temp > 100)
        return "Температура выше точки кипения воды";
    
    return "Температура в нормальном диапазоне";
}

// 90. Функция с несколькими return, которые завершат выполнение в зависимости от условий
static string CategorizeAge(int age)
{
    if (age < 0) return "Неверный возраст";
    if (age < 13) return "Ребенок";
    if (age < 20) return "Подросток";
    if (age < 65) return "Взрослый";
    return "Пожилой";
}

// 91. Функция, возвращающая код ошибки, если входные данные некорректны
static int ValidatePassword(string password)
{
    if (string.IsNullOrEmpty(password)) return -1;
    if (password.Length < 8) return -2;
    return 0;
}

// 92. Функция, возвращающая null, если строка пустая
static string[] SplitWords(string text)
{
    if (string.IsNullOrEmpty(text))
        return null;
    
    return text.Split(' ');
}

// 93. Функция, использующая return для выхода из метода до конца выполнения
static int FindFirstNegative(int[] numbers)
{
    foreach (int num in numbers)
    {
        if (num < 0)
            return num;
    }
    
    return 0; // Если отрицательных нет
}

// 94. Функция, возвращающая код ошибки, если входные данные некорректны
static int ValidateDate(int day, int month, int year)
{
    if (year < 1) return -1;
    if (month < 1 || month > 12) return -2;
    if (day < 1 || day > 31) return -3;
    return 0;
}

// 95. Функция, проверяющая делимость на 3 и возвращающая true/false
static bool IsDivisibleByThree(int number)
{
    return number % 3 == 0;
}

// 96. Функция, проверяющая делимость на 3 и возвращающая true/false
static bool IsDivisibleByThree(int number)
{
    return number % 3 == 0;
}

// 97. Функция, проверяющая делимость на 3 и возвращающая true/false
static bool IsDivisibleByThree(int number)
{
    return number % 3 == 0;
}

// 98. Функция, возвращающая код ошибки, если входные данные некорректны
static int ValidateArray(int[] array)
{
    if (array == null) return -1;
    if (array.Length == 0) return -2;
    return 0;
}

// 99. Функция, использующая return для выхода из метода до конца выполнения
static bool IsPrime(int number)
{
    if (number < 2) return false;
    if (number == 2) return true;
    if (number % 2 == 0) return false;
    
    for (int i = 3; i * i <= number; i += 2)
    {
        if (number % i == 0)
            return false;
    }
    
    return true;
}

// 100. Функция, возвращающая код ошибки, если входные данные некорректны
static int ValidateUserInput(string input, int maxLength)
{
    if (string.IsNullOrEmpty(input)) return -1;
    if (input.Length > maxLength) return -2;
    return 0;
}

// 101. Функция, возвращающая код ошибки, если входные данные некорректны
static int ValidateNumber(int number, int min, int max)
{
    if (number < min) return -1;
    if (number > max) return -2;
    return 0;
}

// 102. Функция, возвращающая null, если строка пустая
static int? ParsePositiveNumber(string str)
{
    if (string.IsNullOrEmpty(str))
        return null;
    
    if (int.TryParse(str, out int result) && result > 0)
        return result;
    
    return null;
}

// 103. Функция, возвращающая null, если строка пустая
static char? GetFirstChar(string str)
{
    if (string.IsNullOrEmpty(str))
        return null;
    
    return str[0];
}

// 104. Функция, использующая return для выхода из метода до конца выполнения
static string ProcessInput(string input)
{
    if (input == "exit" || input == "quit")
        return "Выход из программы";
    
    if (input == "help")
        return "Показать справку";
    
    return $"Обработано: {input}";
}

// 105. Функция, возвращающая null, если строка пустая
static string ReverseIfNotEmpty(string str)
{
    if (string.IsNullOrEmpty(str))
        return null;
    
    return new string(str.Reverse().ToArray());
}

// 106. Функция с Guard Clause для проверки деления на ноль
static double SafeDivide(double a, double b)
{
    if (b == 0)
        throw new DivideByZeroException("Деление на ноль недопустимо");
    
    return a / b;
}

// 107. Guard Clause в конструкторе класса для обязательного параметра
class User
{
    public string Name { get; }
    
    public User(string name)
    {
        if (string.IsNullOrEmpty(name))
            throw new ArgumentException("Имя не может быть пустым");
        
        Name = name;
    }
}

// 108. Функция с Guard Clause для проверки деления на ноль
static int IntegerDivide(int a, int b)
{
    if (b == 0)
    {
        Console.WriteLine("Ошибка: деление на ноль");
        return 0;
    }
    
    return a / b;
}

// 109. Guard Clause для проверки диапазона допустимых значений
static void SetAge(int age)
{
    if (age < 0 || age > 150)
        throw new ArgumentOutOfRangeException(nameof(age), "Возраст должен быть от 0 до 150");
    
    // Основная логика
    Console.WriteLine($"Возраст установлен: {age}");
}

// 110. Guard Clause, которая сразу возвращает void, если массив пустой
static void PrintArray(int[] array)
{
    if (array == null || array.Length == 0)
        return;
    
    foreach (int item in array)
        Console.WriteLine(item);
}

// 111. Guard Clause, которая сразу возвращает void, если массив пустой
static void ProcessArray(int[] array)
{
    if (array == null || array.Length == 0)
        return;
    
    // Основная логика обработки массива
    Array.Sort(array);
}

// 112. Guard Clause в конструкторе класса для обязательного параметра
class Product
{
    public string Name { get; }
    public decimal Price { get; }
    
    public Product(string name, decimal price)
    {
        if (string.IsNullOrEmpty(name))
            throw new ArgumentException("Название товара обязательно");
        
        if (price < 0)
            throw new ArgumentException("Цена не может быть отрицательной");
        
        Name = name;
        Price = price;
    }
}

// 113. Функция с Guard Clause для проверки деления на ноль
static decimal DivideDecimal(decimal a, decimal b)
{
    if (b == 0)
        return 0; // или выбросить исключение
    
    return a / b;
}

// 114. Метод с Guard Clause, выбрасывающей исключение при аргументе null
static void ProcessText(string text)
{
    if (text == null)
        throw new ArgumentNullException(nameof(text));
    
    Console.WriteLine(text.ToUpper());
}

// 115. Метод с Guard Clause, выбрасывающей исключение при аргументе null
static int GetStringLengthSafe(string str)
{
    if (str == null)
        throw new ArgumentNullException(nameof(str));
    
    return str.Length;
}

// 116. Метод с Guard Clause, выбрасывающей исключение при аргументе null
static void ValidateObject(object obj)
{
    if (obj == null)
        throw new ArgumentNullException(nameof(obj));
    
    // Дальнейшая валидация
}

// 117. Guard Clause, которая сразу возвращает void, если массив пустой
static void CalculateSum(int[] numbers)
{
    if (numbers == null || numbers.Length == 0)
        return;
    
    int sum = 0;
    foreach (int num in numbers)
        sum += num;
    
    Console.WriteLine($"Сумма: {sum}");
}

// 118. Guard Clause, которая сразу возвращает void, если массив пустой
static void FindMax(int[] array)
{
    if (array == null || array.Length == 0)
        return;
    
    int max = array[0];
    foreach (int num in array)
        if (num > max) max = num;
    
    Console.WriteLine($"Максимум: {max}");
}

// 119. Функция с Guard Clause для проверки деления на ноль
static double CalculateRatio(double numerator, double denominator)
{
    if (denominator == 0)
        return double.NaN;
    
    return numerator / denominator;
}

// 120. Guard Clause в конструкторе класса для обязательного параметра
class BankAccount
{
    public string AccountNumber { get; }
    public decimal Balance { get; private set; }
    
    public BankAccount(string accountNumber, decimal initialBalance)
    {
        if (string.IsNullOrEmpty(accountNumber))
            throw new ArgumentException("Номер счета обязателен");
        
        if (initialBalance < 0)
            throw new ArgumentException("Начальный баланс не может быть отрицательным");
        
        AccountNumber = accountNumber;
        Balance = initialBalance;
    }
}

// 121. Метод с Guard Clause, выбрасывающей исключение при аргументе null
static void SaveToFile(string filename, string content)
{
    if (filename == null)
        throw new ArgumentNullException(nameof(filename));
    
    if (content == null)
        throw new ArgumentNullException(nameof(content));
    
    // Логика сохранения в файл
    File.WriteAllText(filename, content);
}

// 122. Функция с Guard Clause для проверки деления на ноль
static float DivideFloat(float a, float b)
{
    if (Math.Abs(b) < float.Epsilon)
        throw new DivideByZeroException();
    
    return a / b;
}

// 123. Функция с Guard Clause для проверки деления на ноль
static int Modulo(int a, int b)
{
    if (b == 0)
        return 0;
    
    return a % b;
}

// 124. Guard Clause в конструкторе класса для обязательного параметра
class Employee
{
    public string FirstName { get; }
    public string LastName { get; }
    
    public Employee(string firstName, string lastName)
    {
        if (string.IsNullOrEmpty(firstName))
            throw new ArgumentException("Имя обязательно");
        
        if (string.IsNullOrEmpty(lastName))
            throw new ArgumentException("Фамилия обязательна");
        
        FirstName = firstName;
        LastName = lastName;
    }
}

// 125. Функция с Guard Clause для проверки деления на ноль
static double[] NormalizeVector(double[] vector)
{
    if (vector == null || vector.Length == 0)
        return vector;
    
    double sum = 0;
    foreach (double val in vector)
        sum += val;
    
    if (sum == 0)
        return vector; // или выбросить исключение
    
    for (int i = 0; i < vector.Length; i++)
        vector[i] /= sum;
    
    return vector;
}

// 126. Guard Clause в конструкторе класса для обязательного параметра
class Order
{
    public int OrderId { get; }
    public DateTime OrderDate { get; }
    
    public Order(int orderId, DateTime orderDate)
    {
        if (orderId <= 0)
            throw new ArgumentException("ID заказа должен быть положительным");
        
        if (orderDate > DateTime.Now)
            throw new ArgumentException("Дата заказа не может быть в будущем");
        
        OrderId = orderId;
        OrderDate = orderDate;
    }
}

// 127. Guard Clause для проверки диапазона допустимых значений
static void SetPercentage(int percentage)
{
    if (percentage < 0 || percentage > 100)
        throw new ArgumentOutOfRangeException(nameof(percentage), "Процент должен быть от 0 до 100");
    
    Console.WriteLine($"Процент установлен: {percentage}%");
}

// 128. Guard Clause в конструкторе класса для обязательного параметра
class Book
{
    public string Title { get; }
    public string Author { get; }
    public int Year { get; }
    
    public Book(string title, string author, int year)
    {
        if (string.IsNullOrEmpty(title))
            throw new ArgumentException("Название книги обязательно");
        
        if (string.IsNullOrEmpty(author))
            throw new ArgumentException("Автор обязателен");
        
        if (year < 0 || year > DateTime.Now.Year)
            throw new ArgumentException("Год издания невалиден");
        
        Title = title;
        Author = author;
        Year = year;
    }
}

// 129. Метод с Guard Clause, выбрасывающей исключение при аргументе null
static List<string> ParseCSV(string csvData)
{
    if (csvData == null)
        throw new ArgumentNullException(nameof(csvData));
    
    return csvData.Split(',').ToList();
}

// 130. Метод с Guard Clause, выбрасывающей исключение при аргументе null
static void ValidateUser(User user)
{
    if (user == null)
        throw new ArgumentNullException(nameof(user));
    
    // Дальнейшая валидация пользователя
}

// 131. Guard Clause в конструкторе класса для обязательного параметра
class Rectangle
{
    public double Width { get; }
    public double Height { get; }
    
    public Rectangle(double width, double height)
    {
        if (width <= 0)
            throw new ArgumentException("Ширина должна быть положительной");
        
        if (height <= 0)
            throw new ArgumentException("Высота должна быть положительной");
        
        Width = width;
        Height = height;
    }
}

// 132. Guard Clause для проверки диапазона допустимых значений
static void ValidateScore(double score)
{
    if (score < 0 || score > 10)
        throw new ArgumentOutOfRangeException(nameof(score), "Оценка должна быть от 0 до 10");
    
    Console.WriteLine($"Оценка валидна: {score}");
}

// 133. Guard Clause для проверки диапазона допустимых значений
static void CheckTemperatureRange(double temp)
{
    if (temp < -50 || temp > 50)
        throw new ArgumentOutOfRangeException(nameof(temp), "Температура вне допустимого диапазона");
    
    Console.WriteLine($"Температура в норме: {temp}°C");
}

// 134. Метод с Guard Clause, выбрасывающей исключение при аргументе null
static void ProcessList(List<int> numbers)
{
    if (numbers == null)
        throw new ArgumentNullException(nameof(numbers));
    
    foreach (int num in numbers)
        Console.WriteLine(num);
}

// 135. Guard Clause для проверки диапазона допустимых значений
static void ValidateCoordinates(double x, double y)
{
    if (x < -180 || x > 180)
        throw new ArgumentOutOfRangeException(nameof(x), "Координата X должна быть между -180 и 180");
    
    if (y < -90 || y > 90)
        throw new ArgumentOutOfRangeException(nameof(y), "Координата Y должна быть между -90 и 90");
    
    Console.WriteLine($"Координаты валидны: ({x}, {y})");
}

// 136. Функция с Guard Clause для проверки деления на ноль
static decimal CalculateAverage(decimal[] numbers)
{
    if (numbers == null || numbers.Length == 0)
        return 0;
    
    decimal sum = 0;
    foreach (decimal num in numbers)
        sum += num;
    
    return sum / numbers.Length;
}

// 137. Guard Clause, которая сразу возвращает void, если массив пустой
static void DisplayArray(string[] array)
{
    if (array == null || array.Length == 0)
        return;
    
    for (int i = 0; i < array.Length; i++)
        Console.WriteLine($"{i}: {array[i]}");
}

// 138. Функция с Guard Clause для проверки деления на ноль
static double CalculateBMI(double weight, double height)
{
    if (height == 0)
        throw new ArgumentException("Рост не может быть нулевым");
    
    return weight / (height * height);
}

// 139. Метод с Guard Clause, выбрасывающей исключение при аргументе null
static void SerializeObject(object obj)
{
    if (obj == null)
        throw new ArgumentNullException(nameof(obj));
    
    // Логика сериализации
}

// 140. Guard Clause для проверки диапазона допустимых значений
static void ValidateIndex(int index, int arrayLength)
{
    if (index < 0 || index >= arrayLength)
        throw new IndexOutOfRangeException("Индекс вне диапазона массива");
    
    Console.WriteLine($"Индекс валиден: {index}");
}

// 141. Guard Clause для метода расчетов — если сумма отрицательная, вернуть ошибку
static decimal CalculateDiscount(decimal amount, decimal discountRate)
{
    if (amount < 0)
        throw new ArgumentException("Сумма не может быть отрицательной");
    
    if (discountRate < 0 || discountRate > 1)
        throw new ArgumentException("Ставка дисконта должна быть между 0 и 1");
    
    return amount * (1 - discountRate);
}

// 142. В функции проверки возраста использовать Guard Clause — если меньше минимума, return
static string GetAgeCategory(int age)
{
    if (age < 0) return "Неверный возраст";
    if (age < 13) return "Ребенок";
    if (age < 18) return "Подросток";
    if (age < 65) return "Взрослый";
    return "Пожилой";
}

// 143. Guard Clause для метода расчетов — если сумма отрицательная, вернуть ошибку
static decimal CalculateTax(decimal income)
{
    if (income < 0)
        throw new ArgumentException("Доход не может быть отрицательным");
    
    if (income <= 1000) return 0;
    return (income - 1000) * 0.13m;
}

// 144. Guard Clause для метода авторизации — если пароль слишком короткий, выбросить исключение
static void ValidatePassword(string password)
{
    if (string.IsNullOrEmpty(password))
        throw new ArgumentException("Пароль не может быть пустым");
    
    if (password.Length < 8)
        throw new ArgumentException("Пароль должен содержать минимум 8 символов");
    
    // Дополнительные проверки пароля
}

// 145. Guard Clause в функции регистрации, проверяющая уникальность email
static void RegisterUser(string email, string[] existingEmails)
{
    if (string.IsNullOrEmpty(email))
        throw new ArgumentException("Email не может быть пустым");
    
    if (!email.Contains("@"))
        throw new ArgumentException("Неверный формат email");
    
    if (existingEmails.Contains(email))
        throw new ArgumentException("Email уже используется");
    
    // Логика регистрации пользователя
}

// 146. Guard Clause для метода расчетов — если сумма отрицательная, вернуть ошибку
static decimal CalculateInterest(decimal principal, double rate, int years)
{
    if (principal < 0)
        throw new ArgumentException("Основная сумма не может быть отрицательной");
    
    if (rate < 0)
        throw new ArgumentException("Процентная ставка не может быть отрицательной");
    
    if (years < 0)
        throw new ArgumentException("Количество лет не может быть отрицательным");
    
    return principal * (decimal)Math.Pow(1 + rate, years);
}

// 147. Guard Clause для метода расчетов — если сумма отрицательная, вернуть ошибку
static decimal CalculateCommission(decimal amount)
{
    if (amount < 0)
        return 0; // или выбросить исключение
    
    if (amount < 1000) return amount * 0.05m;
    if (amount < 5000) return amount * 0.03m;
    return amount * 0.02m;
}

// 148. В функции проверки возраста использовать Guard Clause — если меньше минимума, return
static bool CanVote(int age)
{
    if (age < 0) return false;
    if (age < 18) return false;
    return true;
}

// 149. В функции проверки возраста использовать Guard Clause — если меньше минимума, return
static bool IsAdult(int age)
{
    if (age < 18) return false;
    return true;
}

// 150. Guard Clause в функции регистрации, проверяющая уникальность email
static bool IsEmailAvailable(string email, string[] usedEmails)
{
    if (string.IsNullOrEmpty(email))
        return false;
    
    return !usedEmails.Contains(email);
}

// 151. В функции проверки возраста использовать Guard Clause — если меньше минимума, return
static string CheckDrivingLicense(int age)
{
    if (age < 16) return "Слишком молод для вождения";
    if (age < 18) return "Можно водить с ограничениями";
    return "Можно водить без ограничений";
}

// 152. Guard Clause для метода расчетов — если сумма отрицательная, вернуть ошибку
static decimal CalculateBonus(decimal salary, decimal performance)
{
    if (salary < 0)
        throw new ArgumentException("Зарплата не может быть отрицательной");
    
    if (performance < 0 || performance > 1)
        throw new ArgumentException("Показатель эффективности должен быть между 0 и 1");
    
    return salary * performance * 0.1m;
}

// 153. Guard Clause для метода расчетов — если сумма отрицательная, вернуть ошибку
static decimal ApplySurcharge(decimal amount, decimal surchargeRate)
{
    if (amount < 0)
        throw new ArgumentException("Сумма не может быть отрицательной");
    
    if (surchargeRate < 0)
        throw new ArgumentException("Надбавка не может быть отрицательной");
    
    return amount * (1 + surchargeRate);
}

// 154. Guard Clause для метода авторизации — если пароль слишком короткий, выбросить исключение
static void CreateUser(string username, string password)
{
    if (string.IsNullOrEmpty(username))
        throw new ArgumentException("Имя пользователя обязательно");
    
    if (string.IsNullOrEmpty(password))
        throw new ArgumentException("Пароль обязателен");
    
    if (password.Length < 6)
        throw new ArgumentException("Пароль должен содержать минимум 6 символов");
    
    // Логика создания пользователя
}

// 155. Guard Clause для метода расчетов — если сумма отрицательная, вернуть ошибку
static decimal CalculateNetSalary(decimal grossSalary, decimal taxRate)
{
    if (grossSalary < 0)
        throw new ArgumentException("Зарплата не может быть отрицательной");
    
    if (taxRate < 0 || taxRate > 1)
        throw new ArgumentException("Налоговая ставка должна быть между 0 и 1");
    
    return grossSalary * (1 - taxRate);
}

// 156. Guard Clause в функции регистрации, проверяющая уникальность email
static void ValidateNewEmail(string email, List<string> existingEmails)
{
    if (string.IsNullOrEmpty(email))
        throw new ArgumentException("Email не может быть пустым");
    
    if (existingEmails.Contains(email))
        throw new ArgumentException("Этот email уже зарегистрирован");
    
    // Дополнительные проверки email
}

// 157. Guard Clause, выбрасывающую исключение при невалидном формате даты
static DateTime ParseDate(string dateString)
{
    if (string.IsNullOrEmpty(dateString))
        throw new ArgumentException("Строка с датой не может быть пустой");
    
    if (!DateTime.TryParse(dateString, out DateTime result))
        throw new FormatException("Неверный формат даты");
    
    return result;
}

// 158. Guard Clause для метода авторизации — если пароль слишком короткий, выбросить исключение
static bool ValidatePasswordStrength(string password)
{
    if (string.IsNullOrEmpty(password))
        return false;
    
    if (password.Length < 8)
        return false;
    
    // Дополнительные проверки сложности пароля
    return true;
}

// 159. Guard Clause для метода авторизации — если пароль слишком короткий, выбросить исключение
static void ChangePassword(string newPassword)
{
    if (string.IsNullOrEmpty(newPassword))
        throw new ArgumentException("Новый пароль не может быть пустым");
    
    if (newPassword.Length < 8)
        throw new ArgumentException("Пароль должен содержать минимум 8 символов");
    
    // Логика смены пароля
}

// 160. Guard Clause в функции регистрации, проверяющая уникальность email
static bool CanRegisterEmail(string email, string[] registeredEmails)
{
    if (string.IsNullOrEmpty(email))
        return false;
    
    if (!email.Contains("@"))
        return false;
    
    return !registeredEmails.Contains(email);
}

// 161. Guard Clause в функции регистрации, проверяющая уникальность email
static void CheckEmailForRegistration(string email, HashSet<string> existingEmails)
{
    if (string.IsNullOrEmpty(email))
        throw new ArgumentException("Email обязателен");
    
    if (existingEmails.Contains(email))
        throw new ArgumentException("Email уже используется");
}

// 162. В функции проверки возраста использовать Guard Clause — если меньше минимума, return
static bool CanRetire(int age)
{
    if (age < 0) return false;
    if (age < 65) return false;
    return true;
}

// 163. Guard Clause для метода авторизации — если пароль слишком короткий, выбросить исключение
static void SetNewPassword(string password)
{
    if (password == null)
        throw new ArgumentNullException(nameof(password));
    
    if (password.Length < 8)
        throw new ArgumentException("Пароль должен содержать минимум 8 символов");
    
    // Установка нового пароля
}

// 164. В функции проверки возраста использовать Guard Clause — если меньше минимума, return
static string GetSchoolLevel(int age)
{
    if (age < 0) return "Неверный возраст";
    if (age < 7) return "Дошкольник";
    if (age < 11) return "Начальная школа";
    if (age < 15) return "Средняя школа";
    return "Старшая школа";
}

// 165. Guard Clause для метода расчетов — если сумма отрицательная, вернуть ошибку
static decimal CalculateRefund(decimal purchaseAmount, int daysSincePurchase)
{
    if (purchaseAmount < 0)
        throw new ArgumentException("Сумма покупки не может быть отрицательной");
    
    if (daysSincePurchase < 0)
        throw new ArgumentException("Количество дней не может быть отрицательным");
    
    if (daysSincePurchase > 30) return 0;
    return purchaseAmount * 0.9m;
}

// 166. Guard Clause для метода авторизации — если пароль слишком короткий, выбросить исключение
static void ResetPassword(string newPassword)
{
    if (newPassword?.Length < 8)
        throw new ArgumentException("Пароль должен содержать минимум 8 символов");
    
    // Логика сброса пароля
}

// 167. Guard Clause для метода авторизации — если пароль слишком короткий, выбросить исключение
static bool IsPasswordSecure(string password)
{
    if (string.IsNullOrEmpty(password)) return false;
    if (password.Length < 8) return false;
    if (!password.Any(char.IsDigit)) return false;
    if (!password.Any(char.IsUpper)) return false;
    return true;
}

// 168. Guard Clause, выбрасывающую исключение при невалидном формате даты
static void ValidateBirthDate(DateTime birthDate)
{
    if (birthDate > DateTime.Now)
        throw new ArgumentException("Дата рождения не может быть в будущем");
    
    if (birthDate < DateTime.Now.AddYears(-150))
        throw new ArgumentException("Дата рождения слишком старая");
    
    // Дополнительные проверки
}

// 169. Guard Clause для метода авторизации — если пароль слишком короткий, выбросить исключение
static void UpdatePassword(string currentPassword, string newPassword)
{
    if (string.IsNullOrEmpty(newPassword))
        throw new ArgumentException("Новый пароль не может быть пустым");
    
    if (newPassword.Length < 8)
        throw new ArgumentException("Новый пароль должен содержать минимум 8 символов");
    
    if (newPassword == currentPassword)
        throw new ArgumentException("Новый пароль должен отличаться от старого");
    
    // Логика обновления пароля
}

// 170. Guard Clause для метода расчетов — если сумма отрицательная, вернуть ошибку
static decimal CalculateShipping(decimal orderAmount, decimal distance)
{
    if (orderAmount < 0)
        throw new ArgumentException("Сумма заказа не может быть отрицательной");
    
    if (distance < 0)
        throw new ArgumentException("Расстояние не может быть отрицательным");
    
    decimal baseShipping = 5.0m;
    if (orderAmount > 50) baseShipping = 0;
    
    return baseShipping + distance * 0.1m;
}

// 171. Функция деления, возвращающая частное и остаток через out
static bool Divide(int dividend, int divisor, out int quotient, out int remainder)
{
    quotient = 0;
    remainder = 0;
    
    if (divisor == 0)
        return false;
    
    quotient = dividend / divisor;
    remainder = dividend % divisor;
    return true;
}

// 172. Функция деления, возвращающую частное и остаток через out
static void IntegerDivision(int a, int b, out int result, out int remainder)
{
    result = a / b;
    remainder = a % b;
}

// 173. Метод, заполняющий массив результатами через out
static void GenerateSquares(int n, out int[] squares)
{
    squares = new int[n];
    for (int i = 0; i < n; i++)
        squares[i] = (i + 1) * (i + 1);
}

// 174. Метод, который возвращает true/false через return, а результат через out
static bool TryParsePositive(string input, out int result)
{
    result = 0;
    
    if (string.IsNullOrEmpty(input))
        return false;
    
    if (!int.TryParse(input, out int parsed) || parsed <= 0)
        return false;
    
    result = parsed;
    return true;
}

// 175. Функция деления, возвращающая частное и остаток через out
static bool SafeDivide(int a, int b, out double quotient, out double remainder)
{
    quotient = 0;
    remainder = 0;
    
    if (b == 0)
        return false;
    
    quotient = (double)a / b;
    remainder = a % b;
    return true;
}

// 176. Метод, увеличивающий значение аргумента через ref
static void Increment(ref int value)
{
    value++;
}

// 177. Метод, который возвращает true/false через return, а результат через out
static bool TryFindMax(int[] array, out int max)
{
    max = 0;
    
    if (array == null || array.Length == 0)
        return false;
    
    max = array[0];
    foreach (int num in array)
        if (num > max) max = num;
    
    return true;
}

// 178. Метод, который возвращает true/false через return, а результат через out
static bool TryGetFirstEven(int[] numbers, out int firstEven)
{
    firstEven = 0;
    
    if (numbers == null)
        return false;
    
    foreach (int num in numbers)
    {
        if (num % 2 == 0)
        {
            firstEven = num;
            return true;
        }
    }
    
    return false;
}

// 179. Метод, заполняющий массив результатами через out
static void CreateFibonacciSequence(int length, out int[] fibonacci)
{
    fibonacci = new int[length];
    if (length > 0) fibonacci[0] = 0;
    if (length > 1) fibonacci[1] = 1;
    
    for (int i = 2; i < length; i++)
        fibonacci[i] = fibonacci[i - 1] + fibonacci[i - 2];
}

// 180. Функция деления, возвращающая частное и остаток через out
static void CalculateDivision(int numerator, int denominator, out double quotient, out int remainder)
{
    quotient = (double)numerator / denominator;
    remainder = numerator % denominator;
}

// 181. Метод, который возвращает true/false через return, а результат через out
static bool TryCalculateAverage(double[] numbers, out double average)
{
    average = 0;
    
    if (numbers == null || numbers.Length == 0)
        return false;
    
    double sum = 0;
    foreach (double num in numbers)
        sum += num;
    
    average = sum / numbers.Length;
    return true;
}

// 182. Функция деления, возвращающая частное и остаток через out
static bool TryModulo(int a, int b, out int result)
{
    result = 0;
    
    if (b == 0)
        return false;
    
    result = a % b;
    return true;
}

// 183. Метод, увеличивающий значение аргумента через ref
static void DoubleValue(ref int value)
{
    value *= 2;
}

// 184. Метод, заполняющий массив результатами через out
static void GeneratePowersOfTwo(int count, out long[] powers)
{
    powers = new long[count];
    long value = 1;
    
    for (int i = 0; i < count; i++)
    {
        powers[i] = value;
        value *= 2;
    }
}

// 185. Метод, увеличивающий значение аргумента через ref
static void AddTen(ref int number)
{
    number += 10;
}

// 186. Метод, заполняющий массив результатами через out
static void CreateRandomArray(int size, int min, int max, out int[] randomArray)
{
    randomArray = new int[size];
    Random rand = new Random();
    
    for (int i = 0; i < size; i++)
        randomArray[i] = rand.Next(min, max + 1);
}

// 187. Метод, который возвращает true/false через return, а результат через out
static bool TryParseDate(string dateString, out DateTime result)
{
    return DateTime.TryParse(dateString, out result);
}

// 188. Метод, заполняющий массив результатами через out
static void GenerateMultiples(int number, int count, out int[] multiples)
{
    multiples = new int[count];
    for (int i = 0; i < count; i++)
        multiples[i] = number * (i + 1);
}

// 189. Метод, меняющий местами два значения через ref
static void Swap(ref int a, ref int b)
{
    int temp = a;
    a = b;
    b = temp;
}

// 190. Функция деления, возвращающая частное и остаток через out
static void PerformDivision(decimal a, decimal b, out decimal quotient, out decimal remainder)
{
    quotient = a / b;
    remainder = a % b;
}

// 191. Функция деления, возвращающая частное и остаток через out
static bool IntegerDivideWithCheck(int a, int b, out int quotient, out int remainder)
{
    quotient = 0;
    remainder = 0;
    
    if (b == 0)
        return false;
    
    quotient = a / b;
    remainder = a % b;
    return true;
}

// 192. Метод, меняющий местами два значения через ref
static void SwapStrings(ref string a, ref string b)
{
    string temp = a;
    a = b;
    b = temp;
}

// 193. Метод, увеличивающий значение аргумента через ref
static void SquareValue(ref int value)
{
    value = value * value;
}

// 194. Метод, меняющий местами два значения через ref
static void SwapDoubles(ref double a, ref double b)
{
    double temp = a;
    a = b;
    b = temp;
}

// 195. Метод, который возвращает true/false через return, а результат через out
static bool TryFindIndex(string[] array, string search, out int index)
{
    index = -1;
    
    if (array == null)
        return false;
    
    for (int i = 0; i < array.Length; i++)
    {
        if (array[i] == search)
        {
            index = i;
            return true;
        }
    }
    
    return false;
}

// 196. Метод, который возвращает true/false через return, а результат через out
static bool TryGetUserInput(out string input)
{
    input = Console.ReadLine();
    return !string.IsNullOrEmpty(input);
}

// 197. Функция деления, возвращающая частное и остаток через out
static void DivideDoubles(double a, double b, out double quotient, out double remainder)
{
    quotient = a / b;
    remainder = a % b;
}

// 198. Метод, который возвращает true/false через return, а результат через out
static bool TryConvertToInt(string input, out int result)
{
    return int.TryParse(input, out result);
}

// 199. Функция деления, возвращающая частное и остаток через out
static bool TryDecimalDivision(decimal a, decimal b, out decimal quotient, out decimal remainder)
{
    quotient = 0;
    remainder = 0;
    
    if (b == 0)
        return false;
    
    quotient = a / b;
    remainder = a % b;
    return true;
}

// 200. Метод, меняющий местами два значения через ref
static void SwapChars(ref char a, ref char b)
{
    char temp = a;
    a = b;
    b = temp;
}
